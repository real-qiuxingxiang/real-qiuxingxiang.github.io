<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C on Q's Blog</title><link>https://xingxiang.me/tags/c/</link><description>Recent content in C on Q's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Thu, 28 Dec 2017 05:46:56 +0000</lastBuildDate><atom:link href="https://xingxiang.me/tags/c/index.xml" rel="self" type="application/rss+xml"/><item><title>C语言 动态创建链表 Linked List</title><link>https://xingxiang.me/blog/914/</link><pubDate>Thu, 28 Dec 2017 05:46:56 +0000</pubDate><guid>https://xingxiang.me/blog/914/</guid><description>#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; typedef struct LinkedListNode { int data; struct LinkedListNode *next; } NODE; NODE *creatList(int n, int m) { NODE *temp=NULL; NODE *origin; NODE *extend; origin=(NODE*)malloc(sizeof(NODE)); temp=origin; origin-&amp;gt;next=NULL; for(int i=1;i&amp;amp;lt;=n;i+=1){ extend=(NODE*)malloc(sizeof(NODE)); extend-&amp;gt;data=i; extend-&amp;gt;next=origin-&amp;gt;next; origin-&amp;gt;next=extend; origin=origin-&amp;gt;next; } return temp; } void outputLink(NODE *head) { NODE *temp; temp=head-&amp;gt;next; printf(&amp;#34;HEAD&amp;#34;); while(temp){ printf(&amp;#34;-&amp;gt;%d&amp;#34;,temp-&amp;gt;data); temp=temp-&amp;gt;next; } } int main() { NODE *head; head=creatList(10,10); outputLink(head); return 0; }</description></item><item><title>C语言 大数加法 减法 乘法</title><link>https://xingxiang.me/blog/902/</link><pubDate>Mon, 27 Nov 2017 14:36:45 +0000</pubDate><guid>https://xingxiang.me/blog/902/</guid><description>#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; void stringReverse(char * p)//逆序字符串 { int i,len; char temp; len = strlen(p); for(i=0; i&amp;amp;lt;(len/2); i++) { temp = p[i]; p[i] = p[len-1-i]; p[len-1-i] = temp; } } char* getString()//动态字符串输入 { char *str; char *_str; int i=1; str=(char*)malloc(sizeof(char)*(i+1)); while((str[i-1]=getchar())!=&amp;#39;\n&amp;#39;){ i+=1; _str=(char*)malloc(strlen(str)+1); str[i-1]=&amp;#39;\0&amp;#39;; strcpy(_str,str); free(str); str=(char*)malloc(sizeof(char)*(i+1)); if(str==NULL){ free(_str); printf(&amp;#34;Not enough memory!&amp;#34;); return NULL; } strcpy(str,_str); free(_str); } str[i-1]=&amp;#39;\0&amp;#39;; return str; } char* remove_0(char *c)//删除0 { char *temp,*ch; temp=c; while(*temp){ if(*temp!</description></item><item><title>C语言 扫雷</title><link>https://xingxiang.me/blog/890/</link><pubDate>Mon, 04 Sep 2017 03:44:42 +0000</pubDate><guid>https://xingxiang.me/blog/890/</guid><description>Minesweeper in C
C语言扫雷
9*9
可以自动消除一大片
代码如下：
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;time.h&amp;gt; #define N 9 //9*9扫雷 int sum = 10; //雷数目 int mine[N][N] = {0}; //雷数组 int map[N][N]; //显示数组 int markDirection[8][2] = {{0,1},{1,1},{1,0},{1,-1},{0,-1},{-1,-1},{-1,0},{-1,1}}; //8个方向 void printMap() //打印地图 { int i = 0,j = 0; for(i=0;i&amp;amp;lt;N;i++) { for(j=0;j&amp;amp;lt;N;j++) { printf(&amp;#34;%d &amp;#34;,map[i][j]); } printf(&amp;#34;\n&amp;#34;); } } void setMine() //埋雷 { srand((int)time(0)); int x=0,y=0; while(sum &amp;gt;= 0) { x = (rand()%(9-1+1))+1; y = (rand()%(9-1+1))+1; if(mine[x][y] !</description></item></channel></rss>